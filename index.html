<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Neural Trading Oracle - XAU/USD</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
    body {
      font-family: 'Inter', sans-serif;
      background-color: #0f172a;
      color: #e2e8f0;
      margin: 0;
      padding: 0;
    }
    .pulse {
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
      100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
    }
    .pulse-sell {
      animation: pulse-sell 1.5s infinite;
    }
    @keyframes pulse-sell {
      0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
      100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-100">
  <div id="root">Loading Neural Oracle...</div>

  <script type="text/babel">
    const { useState, useEffect, useReducer, createContext, useContext, useRef } = React;

    // ========== API KEY FINNHUB (SUDAH VALID) ==========
    const FINNHUB_API_KEY = 'd3lkfl9r01qq28enskg0d3lkfl9r01qq28enskgg';

    // ========== CONTEXT & REDUCER ==========
    const OracleContext = createContext();

    const initialState = {
      isOracleActive: true,
      timeframe: '1',
      sensitivity: 70,
      latestPrice: null,
      lastSignal: null,
      lastSavedSignal: null,
      signalHistory: [],
      indicators: {
        rsi: [],
        macd: { macd: [], signal: [], histogram: [] },
        bollinger: { upper: [], middle: [], lower: [] }
      },
      detectedPatterns: [],
      confidenceScore: 0.5,
      volatility: 'Low',
      primaryDrivers: '',
      connectionStatus: 'Connecting...',
      candles: [],
      currentInterval: 1000, // Mulai dari 1 detik
      lastError: null
    };

    const oracleReducer = (state, action) => {
      switch (action.type) {
        case 'SET_ORACLE_ACTIVE': return { ...state, isOracleActive: action.payload };
        case 'SET_TIMEFRAME': return { ...state, timeframe: action.payload };
        case 'SET_SENSITIVITY': return { ...state, sensitivity: action.payload };
        case 'UPDATE_MARKET_DATA': return { ...state, candles: action.payload.candles, latestPrice: action.payload.latestPrice };
        case 'UPDATE_INDICATORS': return { ...state, indicators: action.payload };
        case 'UPDATE_PATTERNS': return { ...state, detectedPatterns: action.payload };
        case 'GENERATE_SIGNAL':
          const { signal, confidence, drivers, volatility } = action.payload;
          let newHistory = state.signalHistory;
          let newLastSaved = state.lastSavedSignal;

          if (signal !== 'NEUTRAL' && signal !== state.lastSavedSignal) {
            newHistory = [
              {
                timestamp: new Date().toISOString(),
                signal,
                confidence,
                price: state.latestPrice,
                drivers
              },
              ...state.signalHistory.slice(0, 49)
            ];
            newLastSaved = signal;
          }

          return {
            ...state,
            lastSignal: signal,
            confidenceScore: confidence,
            primaryDrivers: drivers,
            volatility,
            lastSavedSignal: newLastSaved,
            signalHistory: newHistory
          };
        case 'SET_CONNECTION_STATUS': return { ...state, connectionStatus: action.payload, lastError: null };
        case 'SET_ERROR': return { ...state, connectionStatus: 'Reconnecting...', lastError: action.payload };
        case 'UPDATE_INTERVAL': return { ...state, currentInterval: action.payload };
        default: return state;
      }
    };

    // ========== FETCH DATA DENGAN PENANGANAN ERROR ==========
    const fetchMarketData = async (symbol = 'OANDA:XAU_USD', resolution = 1) => {
      const to = Math.floor(Date.now() / 1000);
      const from = to - (100 * resolution * 60);

      const url = `https://finnhub.io/api/v1/forex/candle?symbol=${encodeURIComponent(symbol)}&resolution=${resolution}&from=${from}&to=${to}&token=${FINNHUB_API_KEY}`;
      const res = await fetch(url);
      
      if (res.status === 429) {
        throw new Error('Rate limit exceeded (429)');
      }
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }
      
      const data = await res.json();
      if (data.s !== 'ok') {
        throw new Error(data.msg || 'No data');
      }

      const candles = [];
      for (let i = 0; i < data.c.length; i++) {
        candles.push({
          time: data.t[i],
          open: data.o[i],
          high: data.h[i],
          low: data.l[i],
          close: data.c[i]
        });
      }
      return {
        candles,
        latestPrice: candles.length ? candles[candles.length - 1].close : null
      };
    };

    // ========== INDIKATOR & LOGIKA SAMA (DIPERSINGKAT UNTUK RUANG) ==========
    const calculateRSI = (prices, period = 14) => {
      if (prices.length < period + 1) return [];
      const changes = prices.slice(1).map((p, i) => p - prices[i]);
      const gains = changes.map(c => c > 0 ? c : 0);
      const losses = changes.map(c => c < 0 ? -c : 0);
      let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
      let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
      const rsi = Array(period).fill(null);
      for (let i = period; i < prices.length; i++) {
        avgGain = (avgGain * (period - 1) + gains[i]) / period;
        avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
        const rs = avgLoss === 0 ? Infinity : avgGain / avgLoss;
        rsi.push(100 - (100 / (1 + rs)));
      }
      return rsi;
    };

    const calculateMACD = (prices, fast = 12, slow = 26, signal = 9) => {
      const ema = (data, period) => {
        const k = 2 / (period + 1);
        const ema = [data[0]];
        for (let i = 1; i < data.length; i++) {
          ema[i] = data[i] * k + ema[i - 1] * (1 - k);
        }
        return ema;
      };
      if (prices.length < slow + signal) return { macd: [], signal: [], histogram: [] };
      const fastEma = ema(prices, fast);
      const slowEma = ema(prices, slow);
      const macdLine = fastEma.map((f, i) => f - slowEma[i]);
      const signalLine = ema(macdLine.slice(slow - 1), signal);
      const histogram = macdLine.slice(slow - 1).map((m, i) => m - signalLine[i]);
      return { macd: macdLine.slice(slow - 1), signal: signalLine, histogram };
    };

    const calculateBollingerBands = (prices, period = 20, stdDev = 2) => {
      if (prices.length < period) return { upper: [], middle: [], lower: [] };
      const sma = prices.map((_, i, arr) => {
        if (i < period - 1) return null;
        return arr.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0) / period;
      }).filter(v => v !== null);
      const upper = [], middle = [], lower = [];
      for (let i = 0; i < sma.length; i++) {
        const slice = prices.slice(i, i + period);
        const mean = sma[i];
        const std = Math.sqrt(slice.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / period);
        upper.push(mean + (stdDev * std));
        middle.push(mean);
        lower.push(mean - (stdDev * std));
      }
      return { upper, middle, lower };
    };

    const detectCandlestickPatterns = (candles) => {
      if (candles.length < 3) return [];
      const patterns = [];
      const len = candles.length;

      const isBullishEngulfing = (i) => {
        if (i < 1) return false;
        const p = candles[i - 1], c = candles[i];
        return p.close < p.open && c.close > c.open && c.open < p.close && c.close > p.open;
      };
      const isBearishEngulfing = (i) => {
        if (i < 1) return false;
        const p = candles[i - 1], c = candles[i];
        return p.close > p.open && c.close < c.open && c.open > p.close && c.close < p.open;
      };
      const isHammer = (i) => {
        const c = candles[i];
        const body = Math.abs(c.close - c.open);
        const lower = c.open > c.close ? c.open - c.low : c.close - c.low;
        const upper = c.high - (c.open > c.close ? c.close : c.open);
        return lower > 2 * body && upper < body;
      };
      const isShootingStar = (i) => {
        const c = candles[i];
        const body = Math.abs(c.close - c.open);
        const upper = c.high - (c.open > c.close ? c.open : c.close);
        const lower = c.open > c.close ? c.close - c.low : c.open - c.low;
        return upper > 2 * body && lower < body;
      };
      const isMorningStar = (i) => {
        if (i < 2) return false;
        const [c1, c2, c3] = [candles[i - 2], candles[i - 1], candles[i]];
        return c1.close < c1.open && Math.abs(c2.close - c2.open) <= (c2.high - c2.low) * 0.3 && c3.close > c3.open && c3.close > c1.open;
      };
      const isEveningStar = (i) => {
        if (i < 2) return false;
        const [c1, c2, c3] = [candles[i - 2], candles[i - 1], candles[i]];
        return c1.close > c1.open && Math.abs(c2.close - c2.open) <= (c2.high - c2.low) * 0.3 && c3.close < c3.open && c3.close < c1.open;
      };

      for (let i = len - 1; i >= Math.max(0, len - 10); i--) {
        if (isBullishEngulfing(i)) patterns.push({ type: 'Bullish Engulfing', index: i });
        if (isBearishEngulfing(i)) patterns.push({ type: 'Bearish Engulfing', index: i });
        if (isHammer(i)) patterns.push({ type: 'Hammer', index: i });
        if (isShootingStar(i)) patterns.push({ type: 'Shooting Star', index: i });
        if (isMorningStar(i)) patterns.push({ type: 'Morning Star', index: i });
        if (isEveningStar(i)) patterns.push({ type: 'Evening Star', index: i });
      }
      return patterns;
    };

    const runSynapticIntelligenceEngine = (indicators, patterns, price, sensitivity) => {
      let score = 0.5;
      const drivers = [];
      const rsi = indicators.rsi[indicators.rsi.length - 1];
      const bb = indicators.bollinger;
      const inLowerBB = bb.lower.length > 0 && price <= bb.lower[bb.lower.length - 1];
      const inUpperBB = bb.upper.length > 0 && price >= bb.upper[bb.upper.length - 1];

      const recentPatterns = patterns.filter(p => p.index >= (patterns.length ? patterns[0].index - 2 : -1));
      const hasBullishEngulfing = recentPatterns.some(p => p.type === 'Bullish Engulfing');
      const hasBearishEngulfing = recentPatterns.some(p => p.type === 'Bearish Engulfing');
      const hasHammer = recentPatterns.some(p => p.type === 'Hammer');
      const hasShootingStar = recentPatterns.some(p => p.type === 'Shooting Star');
      const hasMorningStar = recentPatterns.some(p => p.type === 'Morning Star');
      const hasEveningStar = recentPatterns.some(p => p.type === 'Evening Star');

      const oversold = 30 + (100 - sensitivity) * 0.2;
      const overbought = 70 - (100 - sensitivity) * 0.2;

      if (rsi !== undefined && rsi < oversold) {
        if (hasBullishEngulfing && inLowerBB) { score += 0.4; drivers.push('Bullish Engulfing + Oversold RSI + Lower BB'); }
        else if (hasBullishEngulfing) { score += 0.3; drivers.push('Bullish Engulfing + Oversold RSI'); }
        else if (inLowerBB && hasHammer) { score += 0.35; drivers.push('Hammer + Lower BB + Oversold RSI'); }
        else if (inLowerBB) { score += 0.25; drivers.push('Lower BB + Oversold RSI'); }
        else { score += 0.15; drivers.push('Oversold RSI'); }
      }

      if (rsi !== undefined && rsi > overbought) {
        if (hasBearishEngulfing && inUpperBB) { score -= 0.4; drivers.push('Bearish Engulfing + Overbought RSI + Upper BB'); }
        else if (hasBearishEngulfing) { score -= 0.3; drivers.push('Bearish Engulfing + Overbought RSI'); }
        else if (inUpperBB && hasShootingStar) { score -= 0.35; drivers.push('Shooting Star + Upper BB + Overbought RSI'); }
        else if (inUpperBB) { score -= 0.25; drivers.push('Upper BB + Overbought RSI'); }
        else { score -= 0.15; drivers.push('Overbought RSI'); }
      }

      if (hasMorningStar) { score += 0.45; drivers.push('Morning Star'); }
      if (hasEveningStar) { score -= 0.45; drivers.push('Evening Star'); }

      score = Math.max(0, Math.min(1, score));

      let volatility = 'Low';
      const prices = indicators.bollinger.middle;
      if (prices.length > 10) {
        const returns = prices.slice(1).map((p, i) => (p - prices[i]) / prices[i]);
        const std = Math.sqrt(returns.reduce((sum, r) => sum + r * r, 0) / returns.length);
        volatility = std > 0.005 ? 'High' : std > 0.002 ? 'Medium' : 'Low';
      }

      return {
        confidence: score,
        signal: score >= 0.75 ? 'BUY STRONG' :
               score >= 0.55 ? 'BUY' :
               score <= 0.25 ? 'SELL STRONG' :
               score <= 0.45 ? 'SELL' : 'NEUTRAL',
        drivers: drivers.join(', ') || 'Market Noise',
        volatility
      };
    };

    // ========== CHART PANEL ==========
    const ChartPanel = () => {
      const { state } = useContext(OracleContext);
      const mainChartRef = useRef(null);
      const containerRef = useRef(null);

      useEffect(() => {
        if (!containerRef.current || state.candles.length === 0 || typeof LightweightCharts === 'undefined') return;

        try {
          if (mainChartRef.current) mainChartRef.current.remove();
          mainChartRef.current = LightweightCharts.createChart(containerRef.current, {
            width: containerRef.current.clientWidth,
            height: 400,
            layout: { backgroundColor: '#0f172a', textColor: '#e2e8f0' },
            grid: { vertLines: { color: '#1e293b' }, horzLines: { color: '#1e293b' } },
            crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
            rightPriceScale: { borderColor: '#334155' },
            timeScale: { borderColor: '#334155', timeVisible: true }
          });

          const candleSeries = mainChartRef.current.addCandlestickSeries({
            upColor: '#10b981',
            downColor: '#ef4444',
            borderVisible: false,
            wickUpColor: '#10b981',
            wickDownColor: '#ef4444'
          });

          const bbSeries = mainChartRef.current.addBandSeries({
            topColor: 'rgba(99, 102, 241, 0.2)',
            bottomColor: 'rgba(99, 102, 241, 0.2)',
            lineColor: 'rgba(99, 102, 241, 0)',
            lineWidth: 0
          });

          candleSeries.setData(state.candles);

          if (state.indicators.bollinger.upper.length > 0) {
            const bbData = state.candles.slice(-state.indicators.bollinger.upper.length).map((c, i) => ({
              time: c.time,
              top: state.indicators.bollinger.upper[i],
              bottom: state.indicators.bollinger.lower[i]
            }));
            bbSeries.setData(bbData);
          }

          mainChartRef.current.setMarkers([]);
          state.detectedPatterns.forEach(pattern => {
            const candle = state.candles[pattern.index];
            if (candle) {
              mainChartRef.current.setMarkers([
                { time: candle.time, position: 'belowBar', shape: 'circle', color: '#f59e0b', text: pattern.type }
              ]);
            }
          });

          const handleResize = () => {
            if (mainChartRef.current) {
              mainChartRef.current.applyOptions({ width: containerRef.current.clientWidth });
            }
          };
          window.addEventListener('resize', handleResize);
          return () => {
            window.removeEventListener('resize', handleResize);
            if (mainChartRef.current) mainChartRef.current.remove();
          };
        } catch (err) {
          console.error('Chart error:', err);
        }
      }, [state.candles, state.indicators, state.detectedPatterns]);

      return <div ref={containerRef} className="w-full bg-gray-800 rounded-lg"></div>;
    };

    // ========== UI COMPONENTS ==========
    const Header = () => {
      const { state } = useContext(OracleContext);
      return (
        <header className="p-4 border-b border-gray-700">
          <h1 className="text-2xl font-bold text-cyan-400">Neural Trading Oracle - XAU/USD</h1>
          <div className="text-sm text-gray-400 mt-1">
            Status: <span className={state.connectionStatus === 'Connected' ? 'text-green-400' : 'text-yellow-400'}>{state.connectionStatus}</span>
            {state.currentInterval > 1000 && (
              <span className="ml-2 text-xs text-orange-400">(Slowed: {state.currentInterval}ms)</span>
            )}
          </div>
        </header>
      );
    };

    const ControlPanel = () => {
      const { state, dispatch } = useContext(OracleContext);
      return (
        <div className="p-4 bg-gray-800 rounded-lg mb-4">
          <div className="flex flex-wrap gap-4 items-center">
            <button
              onClick={() => dispatch({ type: 'SET_ORACLE_ACTIVE', payload: !state.isOracleActive })}
              className={`px-4 py-2 rounded font-medium ${state.isOracleActive ? 'bg-red-600' : 'bg-green-600'} text-white`}
            >
              {state.isOracleActive ? 'Pause' : 'Activate'}
            </button>
            <div className="flex-1 min-w-[200px]">
              <label className="text-sm text-gray-300 block mb-1">Sensitivity: {state.sensitivity}%</label>
              <input
                type="range"
                min="0"
                max="100"
                value={state.sensitivity}
                onChange={(e) => dispatch({ type: 'SET_SENSITIVITY', payload: parseInt(e.target.value) })}
                className="w-full h-2 bg-gray-700 rounded-lg"
              />
            </div>
          </div>
        </div>
      );
    };

    const SignalPanel = () => {
      const { state } = useContext(OracleContext);
      let cls = 'text-gray-400 bg-gray-800', pulse = '', txt = state.lastSignal || 'AWAITING';
      if (state.lastSignal === 'BUY STRONG') { cls = 'text-green-400 bg-green-900/30'; pulse = 'pulse'; }
      else if (state.lastSignal === 'SELL STRONG') { cls = 'text-red-400 bg-red-900/30'; pulse = 'pulse-sell'; }
      else if (state.lastSignal === 'BUY') cls = 'text-green-300 bg-green-900/20';
      else if (state.lastSignal === 'SELL') cls = 'text-red-300 bg-red-900/20';

      return (
        <div className={`p-6 rounded-xl mb-4 font-bold text-center ${cls} ${pulse}`}>
          <div className="text-2xl">{txt}</div>
          <div className="text-sm mt-2 opacity-80">Confidence: {(state.confidenceScore * 100).toFixed(1)}%</div>
        </div>
      );
    };

    const BrainPanel = () => {
      const { state } = useContext(OracleContext);
      return (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
          <div className="bg-gray-800 p-4 rounded-lg">
            <div className="text-sm text-gray-400">Confidence</div>
            <div className="text-2xl font-bold mt-1">{(state.confidenceScore * 100).toFixed(1)}%</div>
          </div>
          <div className="bg-gray-800 p-4 rounded-lg">
            <div className="text-sm text-gray-400">Volatility</div>
            <div className={`text-lg font-bold mt-1 ${state.volatility === 'High' ? 'text-red-400' : state.volatility === 'Medium' ? 'text-yellow-400' : 'text-gray-400'}`}>
              {state.volatility}
            </div>
          </div>
          <div className="bg-gray-800 p-4 rounded-lg">
            <div className="text-sm text-gray-400">Signal</div>
            <div className="text-sm mt-1 truncate">{state.primaryDrivers || '—'}</div>
          </div>
        </div>
      );
    };

    const LogPanel = () => {
      const { state } = useContext(OracleContext);
      return (
        <div className="mt-6 bg-gray-800 rounded-lg overflow-hidden">
          <div className="p-3 bg-gray-900 font-medium">Signal History (Non-Neutral Only)</div>
          <div className="overflow-x-auto">
            <table className="w-full text-sm">
              <thead className="bg-gray-700">
                <tr>
                  <th className="p-2 text-left">Time</th>
                  <th className="p-2 text-left">Signal</th>
                  <th className="p-2 text-left">Conf.</th>
                  <th className="p-2 text-left">Price</th>
                </tr>
              </thead>
              <tbody>
                {state.signalHistory.length === 0 ? (
                  <tr><td colSpan="4" className="p-4 text-center text-gray-500">No signals yet</td></tr>
                ) : (
                  state.signalHistory.map((log, i) => (
                    <tr key={i} className="border-b border-gray-700">
                      <td className="p-2">{new Date(log.timestamp).toLocaleTimeString()}</td>
                      <td className={`p-2 font-medium ${log.signal.includes('BUY') ? 'text-green-400' : 'text-red-400'}`}>{log.signal}</td>
                      <td className="p-2">{(log.confidence * 100).toFixed(1)}%</td>
                      <td className="p-2">{log.price?.toFixed(2)}</td>
                    </tr>
                  ))
                )}
              </tbody>
            </table>
          </div>
        </div>
      );
    };

    // ========== MAIN APP DENGAN ADAPTIVE POLLING ==========
    const OracleApp = () => {
      const [state, dispatch] = useReducer(oracleReducer, initialState);
      const intervalRef = useRef(null);

      useEffect(() => {
        if (!state.isOracleActive) {
          if (intervalRef.current) clearInterval(intervalRef.current);
          return;
        }

        const fetchData = async () => {
          try {
            const resolution = parseInt(state.timeframe) || 1;
            const marketData = await fetchMarketData('OANDA:XAU_USD', resolution);
            
            dispatch({ type: 'SET_CONNECTION_STATUS', payload: 'Connected' });
            dispatch({ type: 'UPDATE_MARKET_DATA', payload: marketData });

            const prices = marketData.candles.map(c => c.close);
            const indicators = {
              rsi: calculateRSI(prices),
              macd: calculateMACD(prices),
              bollinger: calculateBollingerBands(prices)
            };
            dispatch({ type: 'UPDATE_INDICATORS', payload: indicators });

            const patterns = detectCandlestickPatterns(marketData.candles);
            dispatch({ type: 'UPDATE_PATTERNS', payload: patterns });

            const sieResult = runSynapticIntelligenceEngine(indicators, patterns, marketData.latestPrice, state.sensitivity);
            dispatch({ type: 'GENERATE_SIGNAL', payload: sieResult });

            // Jika sebelumnya lambat, kembali ke 1 detik
            if (state.currentInterval !== 1000) {
              dispatch({ type: 'UPDATE_INTERVAL', payload: 1000 });
            }
          } catch (error) {
            console.error('Fetch error:', error.message);
            dispatch({ type: 'SET_ERROR', payload: error.message });

            // Jika rate limit, perlambat polling
            if (error.message.includes('429') || error.message.includes('rate limit')) {
              const newInterval = Math.min(state.currentInterval * 2, 10000); // max 10 detik
              dispatch({ type: 'UPDATE_INTERVAL', payload: newInterval });
            }
          }
        };

        // Jalankan pertama kali
        fetchData();

        // Set interval dinamis
        const runInterval = () => {
          if (intervalRef.current) clearInterval(intervalRef.current);
          intervalRef.current = setInterval(fetchData, state.currentInterval);
        };

        runInterval();

        return () => {
          if (intervalRef.current) clearInterval(intervalRef.current);
        };
      }, [state.isOracleActive, state.timeframe, state.sensitivity, state.currentInterval]);

      return (
        <OracleContext.Provider value={{ state, dispatch }}>
          <div className="max-w-6xl mx-auto p-4">
            <Header />
            <ControlPanel />
            <SignalPanel />
            <BrainPanel />
            <ChartPanel />
            <LogPanel />
          </div>
        </OracleContext.Provider>
      );
    };

    const waitForCharts = () => {
      if (typeof LightweightCharts !== 'undefined') {
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<OracleApp />);
      } else {
        setTimeout(waitForCharts, 100);
      }
    };
    waitForCharts();
  </script>
</body>
</html>
